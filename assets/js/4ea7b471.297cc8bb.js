"use strict";(self.webpackChunkai_humanoid_robotics_book=self.webpackChunkai_humanoid_robotics_book||[]).push([[6200],{968:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"modules/module-05-capstone/chapter-04-manipulation","title":"Chapter 4: Manipulation & Task Execution","description":"Learning Objectives","source":"@site/docs/modules/module-05-capstone/chapter-04-manipulation.md","sourceDirName":"modules/module-05-capstone","slug":"/modules/module-05-capstone/chapter-04-manipulation","permalink":"/AI-Humanoid-Robotics-Book/docs/modules/module-05-capstone/chapter-04-manipulation","draft":false,"unlisted":false,"editUrl":"https://github.com/asadaligith/AI-Humanoid-Robotics-Book/tree/main/docs/modules/module-05-capstone/chapter-04-manipulation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"3\ufe0f\u20e3 Navigation & Perception","permalink":"/AI-Humanoid-Robotics-Book/docs/modules/module-05-capstone/chapter-03-navigation-perception"},"next":{"title":"5\ufe0f\u20e3 Simulation & Deployment","permalink":"/AI-Humanoid-Robotics-Book/docs/modules/module-05-capstone/chapter-05-simulation-deployment"}}');var r=i(4848),t=i(8453);const o={sidebar_position:4},a="Chapter 4: Manipulation & Task Execution",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"MoveIt 2 Integration for Motion Planning",id:"moveit-2-integration-for-motion-planning",level:2},{value:"Manipulation Controller Architecture",id:"manipulation-controller-architecture",level:3},{value:"Grasp Planning Strategies",id:"grasp-planning-strategies",level:2},{value:"Predefined Grasps",id:"predefined-grasps",level:3},{value:"Heuristic Grasps",id:"heuristic-grasps",level:3},{value:"Failure Handling and Recovery",id:"failure-handling-and-recovery",level:2},{value:"Grasp Failure Recovery",id:"grasp-failure-recovery",level:3},{value:"Unreachable Pose Handling",id:"unreachable-pose-handling",level:3},{value:"Collision Avoidance",id:"collision-avoidance",level:3},{value:"Integration with State Machine",id:"integration-with-state-machine",level:2},{value:"Performance Targets",id:"performance-targets",level:2},{value:"Research &amp; Evidence",id:"research--evidence",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-4-manipulation--task-execution",children:"Chapter 4: Manipulation & Task Execution"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,r.jsx)(n.strong,{children:"Integrate"})," MoveIt 2 for motion planning and collision avoidance"]}),"\n",(0,r.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,r.jsx)(n.strong,{children:"Implement"})," grasp planning with predefined and heuristic approaches"]}),"\n",(0,r.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,r.jsx)(n.strong,{children:"Execute"})," pick-and-place actions with failure recovery"]}),"\n",(0,r.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,r.jsx)(n.strong,{children:"Handle"})," manipulation edge cases (unreachable poses, grasp failures, collisions)"]}),"\n",(0,r.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Completed Chapter 3 (object detected and localized in 3D space)"}),"\n",(0,r.jsx)(n.li,{children:"Understanding of inverse kinematics (IK) and joint space planning"}),"\n",(0,r.jsx)(n.li,{children:"Familiarity with grasp pose representations (position + orientation)"}),"\n",(0,r.jsx)(n.li,{children:"Basic knowledge of collision checking and workspace constraints"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsx)(n.p,{children:"Detecting an object is insufficient\u2014the robot must physically interact with it. Manipulation closes the perception-action loop, transforming detected object poses into joint trajectories that achieve pick-and-place tasks. This chapter integrates MoveIt 2 for collision-free motion planning and implements robust grasp strategies with retry logic, demonstrating how autonomous systems handle the physical uncertainties of the real world."}),"\n",(0,r.jsx)(n.h2,{id:"moveit-2-integration-for-motion-planning",children:"MoveIt 2 Integration for Motion Planning"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"MoveIt 2"})," is ROS 2's motion planning framework, providing inverse kinematics solvers, collision checking, and trajectory execution."]}),"\n",(0,r.jsx)(n.h3,{id:"manipulation-controller-architecture",children:"Manipulation Controller Architecture"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"manipulation_controller.py"})," node interfaces with MoveIt 2's ",(0,r.jsx)(n.code,{children:"MoveGroup"})," action:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from moveit_msgs.action import MoveGroup\nfrom geometry_msgs.msg import PoseStamped\n\nclass ManipulationController(Node):\n    def __init__(self):\n        super().__init__('manipulation_controller')\n        self.moveit_client = ActionClient(self, MoveGroup, 'move_action')\n        self.pick_sub = self.create_subscription(\n            PoseStamped, '/manipulation/pick_target', self.pick_callback, 10)\n\n    def pick_callback(self, target_pose):\n        # Pre-grasp: approach from above\n        pre_grasp_pose = self.compute_pre_grasp(target_pose, offset_z=0.1)\n        self.plan_and_execute(pre_grasp_pose)\n\n        # Grasp: close gripper\n        self.close_gripper()\n\n        # Lift: retract upward\n        lift_pose = self.compute_lift_pose(target_pose, offset_z=0.2)\n        self.plan_and_execute(lift_pose)\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Grasp Pipeline"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pre-Grasp"}),": Approach object from above (avoids collisions)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Grasp"}),": Move to object pose and close gripper"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lift"}),": Retract vertically to clear obstacles"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Transport"}),": Navigate to placement location"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Place"}),": Lower object and open gripper"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"grasp-planning-strategies",children:"Grasp Planning Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"predefined-grasps",children:"Predefined Grasps"}),"\n",(0,r.jsxs)(n.p,{children:["For common objects, use pre-calibrated grasp poses (from ",(0,r.jsx)(n.code,{children:"grasp_poses.yaml"}),"):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"grasp_library:\n  mug:\n    approach_vector: [0, 0, -1]  # Top-down grasp\n    grasp_width: 0.08  # 8cm gripper opening\n    pre_grasp_offset: 0.1  # 10cm above object\n  bottle:\n    approach_vector: [0, 1, 0]  # Side grasp\n    grasp_width: 0.06\n    pre_grasp_offset: 0.05\n"})}),"\n",(0,r.jsx)(n.h3,{id:"heuristic-grasps",children:"Heuristic Grasps"}),"\n",(0,r.jsx)(n.p,{children:"For unknown objects, compute grasps from bounding box geometry:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def compute_heuristic_grasp(self, bbox):\n    # Top-down grasp at bounding box center\n    grasp_pose = PoseStamped()\n    grasp_pose.pose.position.x = bbox.center.x\n    grasp_pose.pose.position.y = bbox.center.y\n    grasp_pose.pose.position.z = bbox.center.z + bbox.size_z / 2\n\n    # Gripper oriented downward\n    grasp_pose.pose.orientation = quaternion_from_euler(0, pi/2, 0)\n    return grasp_pose\n"})}),"\n",(0,r.jsx)(n.h2,{id:"failure-handling-and-recovery",children:"Failure Handling and Recovery"}),"\n",(0,r.jsx)(n.p,{children:"Per spec requirements (FR-011), manipulation must handle edge cases:"}),"\n",(0,r.jsx)(n.h3,{id:"grasp-failure-recovery",children:"Grasp Failure Recovery"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'MAX_RETRIES = 3\nfor attempt in range(MAX_RETRIES):\n    success = self.execute_pick(target_pose)\n    if success:\n        break\n    else:\n        self.get_logger().warn(f"Grasp attempt {attempt+1} failed, retrying...")\n        # Adjust grasp pose (offset by 1cm in random direction)\n        target_pose = self.perturb_pose(target_pose, max_offset=0.01)\n\nif not success:\n    self.get_logger().error("Grasp failed after 3 attempts")\n    self.state = State.FAILED\n'})}),"\n",(0,r.jsx)(n.h3,{id:"unreachable-pose-handling",children:"Unreachable Pose Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'ik_result = self.compute_ik(target_pose)\nif not ik_result.error_code.val == MoveItErrorCodes.SUCCESS:\n    self.get_logger().error(f"IK failed: {ik_result.error_code}")\n    # Request replanning from LLM with different approach\n    self.request_llm_replan("Object unreachable, try different location")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"collision-avoidance",children:"Collision Avoidance"}),"\n",(0,r.jsx)(n.p,{children:"MoveIt 2 automatically checks for collisions using robot's collision meshes and scene obstacles. If planning fails:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'if plan_result.error_code.val == MoveItErrorCodes.PLANNING_FAILED:\n    self.get_logger().warn("Collision detected in path")\n    # Clear costmap and reattempt with conservative planner\n    self.clear_octomap()\n    plan_result = self.plan_with_conservative_settings()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-state-machine",children:"Integration with State Machine"}),"\n",(0,r.jsx)(n.p,{children:"The FSM coordinates manipulation with navigation and perception:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'if self.state == State.MANIPULATING:\n    if self.manip_result.status == GoalStatus.STATUS_SUCCEEDED:\n        self.state = State.COMPLETED\n        self.get_logger().info("Task completed successfully!")\n    elif self.manip_result.status == GoalStatus.STATUS_ABORTED:\n        self.retry_count += 1\n        if self.retry_count < 3:\n            self.state = State.PERCEIVING  # Re-detect object\n        else:\n            self.state = State.FAILED\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-targets",children:"Performance Targets"}),"\n",(0,r.jsx)(n.p,{children:"Per capstone spec (FR-009):"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Success Rate"}),": \u226570% for pick-and-place tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Planning Time"}),": <2 seconds for IK solution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execution Time"}),": <15 seconds for full pick-and-place sequence"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Retry Limit"}),": Maximum 3 attempts before failure"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"research--evidence",children:"Research & Evidence"}),"\n",(0,r.jsx)(n.p,{children:"Manipulation strategies informed by:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["MoveIt 2 Documentation: ",(0,r.jsx)(n.a,{href:"https://moveit.picknik.ai/main",children:"moveit.picknik.ai/main"})]}),"\n",(0,r.jsxs)(n.li,{children:["Grasp Planning Best Practices: ",(0,r.jsx)(n.a,{href:"https://manipulation.csail.mit.edu/",children:"manipulation.csail.mit.edu"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(n.p,{children:"Manipulation transforms detected objects into physical task completion:"}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"MoveIt 2"})," provides collision-free motion planning with configurable planners (OMPL, Pilz) and IK solvers"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Grasp strategies"})," balance efficiency (predefined grasps) with generality (heuristic grasps from geometry)"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"Failure recovery"})," ensures robustness through retry logic, pose perturbation, and LLM replanning requests"]}),"\n",(0,r.jsxs)(n.p,{children:["\u2705 ",(0,r.jsx)(n.strong,{children:"State machine integration"})," sequences navigation \u2192 perception \u2192 manipulation for end-to-end autonomy"]}),"\n",(0,r.jsx)(n.p,{children:"Your capstone system now executes complete fetch-and-deliver tasks from voice commands\u2014demonstrating the full integration of AI and robotics."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next Steps"}),": Explore ",(0,r.jsx)(n.a,{href:"/AI-Humanoid-Robotics-Book/docs/modules/module-05-capstone/testing-methodology",children:"Testing Methodology"})," to validate manipulation in isolation, or proceed to ",(0,r.jsx)(n.a,{href:"/AI-Humanoid-Robotics-Book/docs/modules/module-05-capstone/chapter-05-simulation-deployment",children:"Chapter 5: Simulation Deployment"})," to run the integrated system in Gazebo."]}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.p,{children:["\u2b50 ",(0,r.jsx)(n.strong,{children:"Exercise 1"}),": Measure grasp success rate for 20 trials with varying object positions. Identify dominant failure modes."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2b50\u2b50 ",(0,r.jsx)(n.strong,{children:"Exercise 2"}),": Implement a ",(0,r.jsx)(n.strong,{children:"force-feedback gripper"})," that detects successful grasps by monitoring gripper joint torques (grasp confirmed if torque > threshold)."]}),"\n",(0,r.jsxs)(n.p,{children:["\u2b50\u2b50\u2b50 ",(0,r.jsx)(n.strong,{children:"Exercise 3"}),": Create a ",(0,r.jsx)(n.strong,{children:"learned grasp planner"})," using PointNet++ to predict grasp poses from point cloud data (vs. heuristic bbox approach)."]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Word Count"}),": 285 words (Target: 250-300) \u2705"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const r={},t=s.createContext(r);function o(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);