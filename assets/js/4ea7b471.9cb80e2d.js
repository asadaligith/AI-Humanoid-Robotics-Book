"use strict";(self.webpackChunkai_humanoid_robotics_book=self.webpackChunkai_humanoid_robotics_book||[]).push([[6200],{968:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"modules/module-05-capstone/chapter-04-manipulation","title":"Chapter 4: Manipulation & Task Execution","description":"Learning Objectives","source":"@site/docs/modules/module-05-capstone/chapter-04-manipulation.md","sourceDirName":"modules/module-05-capstone","slug":"/modules/module-05-capstone/chapter-04-manipulation","permalink":"/docs/modules/module-05-capstone/chapter-04-manipulation","draft":false,"unlisted":false,"editUrl":"https://github.com/asadaligith/AI-Humanoid-Robotics-Book/tree/main/docs/modules/module-05-capstone/chapter-04-manipulation.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"3\ufe0f\u20e3 Navigation & Perception","permalink":"/docs/modules/module-05-capstone/chapter-03-navigation-perception"},"next":{"title":"5\ufe0f\u20e3 Simulation & Deployment","permalink":"/docs/modules/module-05-capstone/chapter-05-simulation-deployment"}}');var s=r(4848),t=r(8453);const o={sidebar_position:4},a="Chapter 4: Manipulation & Task Execution",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Introduction",id:"introduction",level:2},{value:"MoveIt 2 Integration for Motion Planning",id:"moveit-2-integration-for-motion-planning",level:2},{value:"Manipulation Controller Architecture",id:"manipulation-controller-architecture",level:3},{value:"Grasp Planning Strategies",id:"grasp-planning-strategies",level:2},{value:"Predefined Grasps",id:"predefined-grasps",level:3},{value:"Heuristic Grasps",id:"heuristic-grasps",level:3},{value:"Failure Handling and Recovery",id:"failure-handling-and-recovery",level:2},{value:"Grasp Failure Recovery",id:"grasp-failure-recovery",level:3},{value:"Unreachable Pose Handling",id:"unreachable-pose-handling",level:3},{value:"Collision Avoidance",id:"collision-avoidance",level:3},{value:"Integration with State Machine",id:"integration-with-state-machine",level:2},{value:"Performance Targets",id:"performance-targets",level:2},{value:"Research &amp; Evidence",id:"research--evidence",level:2},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function p(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"chapter-4-manipulation--task-execution",children:"Chapter 4: Manipulation & Task Execution"})}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,s.jsx)(n.strong,{children:"Integrate"})," MoveIt 2 for motion planning and collision avoidance"]}),"\n",(0,s.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,s.jsx)(n.strong,{children:"Implement"})," grasp planning with predefined and heuristic approaches"]}),"\n",(0,s.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,s.jsx)(n.strong,{children:"Execute"})," pick-and-place actions with failure recovery"]}),"\n",(0,s.jsxs)(n.p,{children:["\ud83c\udfaf ",(0,s.jsx)(n.strong,{children:"Handle"})," manipulation edge cases (unreachable poses, grasp failures, collisions)"]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Completed Chapter 3 (object detected and localized in 3D space)"}),"\n",(0,s.jsx)(n.li,{children:"Understanding of inverse kinematics (IK) and joint space planning"}),"\n",(0,s.jsx)(n.li,{children:"Familiarity with grasp pose representations (position + orientation)"}),"\n",(0,s.jsx)(n.li,{children:"Basic knowledge of collision checking and workspace constraints"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Detecting an object is insufficient\u2014the robot must physically interact with it. Manipulation closes the perception-action loop, transforming detected object poses into joint trajectories that achieve pick-and-place tasks. This chapter integrates MoveIt 2 for collision-free motion planning and implements robust grasp strategies with retry logic, demonstrating how autonomous systems handle the physical uncertainties of the real world."}),"\n",(0,s.jsx)(n.h2,{id:"moveit-2-integration-for-motion-planning",children:"MoveIt 2 Integration for Motion Planning"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"MoveIt 2"})," is ROS 2's motion planning framework, providing inverse kinematics solvers, collision checking, and trajectory execution."]}),"\n",(0,s.jsx)(n.h3,{id:"manipulation-controller-architecture",children:"Manipulation Controller Architecture"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"manipulation_controller.py"})," node interfaces with MoveIt 2's ",(0,s.jsx)(n.code,{children:"MoveGroup"})," action:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from moveit_msgs.action import MoveGroup\r\nfrom geometry_msgs.msg import PoseStamped\r\n\r\nclass ManipulationController(Node):\r\n    def __init__(self):\r\n        super().__init__('manipulation_controller')\r\n        self.moveit_client = ActionClient(self, MoveGroup, 'move_action')\r\n        self.pick_sub = self.create_subscription(\r\n            PoseStamped, '/manipulation/pick_target', self.pick_callback, 10)\r\n\r\n    def pick_callback(self, target_pose):\r\n        # Pre-grasp: approach from above\r\n        pre_grasp_pose = self.compute_pre_grasp(target_pose, offset_z=0.1)\r\n        self.plan_and_execute(pre_grasp_pose)\r\n\r\n        # Grasp: close gripper\r\n        self.close_gripper()\r\n\r\n        # Lift: retract upward\r\n        lift_pose = self.compute_lift_pose(target_pose, offset_z=0.2)\r\n        self.plan_and_execute(lift_pose)\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Grasp Pipeline"}),":"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Pre-Grasp"}),": Approach object from above (avoids collisions)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Grasp"}),": Move to object pose and close gripper"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lift"}),": Retract vertically to clear obstacles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Transport"}),": Navigate to placement location"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Place"}),": Lower object and open gripper"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"grasp-planning-strategies",children:"Grasp Planning Strategies"}),"\n",(0,s.jsx)(n.h3,{id:"predefined-grasps",children:"Predefined Grasps"}),"\n",(0,s.jsxs)(n.p,{children:["For common objects, use pre-calibrated grasp poses (from ",(0,s.jsx)(n.code,{children:"grasp_poses.yaml"}),"):"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"grasp_library:\r\n  mug:\r\n    approach_vector: [0, 0, -1]  # Top-down grasp\r\n    grasp_width: 0.08  # 8cm gripper opening\r\n    pre_grasp_offset: 0.1  # 10cm above object\r\n  bottle:\r\n    approach_vector: [0, 1, 0]  # Side grasp\r\n    grasp_width: 0.06\r\n    pre_grasp_offset: 0.05\n"})}),"\n",(0,s.jsx)(n.h3,{id:"heuristic-grasps",children:"Heuristic Grasps"}),"\n",(0,s.jsx)(n.p,{children:"For unknown objects, compute grasps from bounding box geometry:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def compute_heuristic_grasp(self, bbox):\r\n    # Top-down grasp at bounding box center\r\n    grasp_pose = PoseStamped()\r\n    grasp_pose.pose.position.x = bbox.center.x\r\n    grasp_pose.pose.position.y = bbox.center.y\r\n    grasp_pose.pose.position.z = bbox.center.z + bbox.size_z / 2\r\n\r\n    # Gripper oriented downward\r\n    grasp_pose.pose.orientation = quaternion_from_euler(0, pi/2, 0)\r\n    return grasp_pose\n"})}),"\n",(0,s.jsx)(n.h2,{id:"failure-handling-and-recovery",children:"Failure Handling and Recovery"}),"\n",(0,s.jsx)(n.p,{children:"Per spec requirements (FR-011), manipulation must handle edge cases:"}),"\n",(0,s.jsx)(n.h3,{id:"grasp-failure-recovery",children:"Grasp Failure Recovery"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'MAX_RETRIES = 3\r\nfor attempt in range(MAX_RETRIES):\r\n    success = self.execute_pick(target_pose)\r\n    if success:\r\n        break\r\n    else:\r\n        self.get_logger().warn(f"Grasp attempt {attempt+1} failed, retrying...")\r\n        # Adjust grasp pose (offset by 1cm in random direction)\r\n        target_pose = self.perturb_pose(target_pose, max_offset=0.01)\r\n\r\nif not success:\r\n    self.get_logger().error("Grasp failed after 3 attempts")\r\n    self.state = State.FAILED\n'})}),"\n",(0,s.jsx)(n.h3,{id:"unreachable-pose-handling",children:"Unreachable Pose Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'ik_result = self.compute_ik(target_pose)\r\nif not ik_result.error_code.val == MoveItErrorCodes.SUCCESS:\r\n    self.get_logger().error(f"IK failed: {ik_result.error_code}")\r\n    # Request replanning from LLM with different approach\r\n    self.request_llm_replan("Object unreachable, try different location")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"collision-avoidance",children:"Collision Avoidance"}),"\n",(0,s.jsx)(n.p,{children:"MoveIt 2 automatically checks for collisions using robot's collision meshes and scene obstacles. If planning fails:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'if plan_result.error_code.val == MoveItErrorCodes.PLANNING_FAILED:\r\n    self.get_logger().warn("Collision detected in path")\r\n    # Clear costmap and reattempt with conservative planner\r\n    self.clear_octomap()\r\n    plan_result = self.plan_with_conservative_settings()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-state-machine",children:"Integration with State Machine"}),"\n",(0,s.jsx)(n.p,{children:"The FSM coordinates manipulation with navigation and perception:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'if self.state == State.MANIPULATING:\r\n    if self.manip_result.status == GoalStatus.STATUS_SUCCEEDED:\r\n        self.state = State.COMPLETED\r\n        self.get_logger().info("Task completed successfully!")\r\n    elif self.manip_result.status == GoalStatus.STATUS_ABORTED:\r\n        self.retry_count += 1\r\n        if self.retry_count < 3:\r\n            self.state = State.PERCEIVING  # Re-detect object\r\n        else:\r\n            self.state = State.FAILED\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-targets",children:"Performance Targets"}),"\n",(0,s.jsx)(n.p,{children:"Per capstone spec (FR-009):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Success Rate"}),": \u226570% for pick-and-place tasks"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Planning Time"}),": <2 seconds for IK solution"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execution Time"}),": <15 seconds for full pick-and-place sequence"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Retry Limit"}),": Maximum 3 attempts before failure"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"research--evidence",children:"Research & Evidence"}),"\n",(0,s.jsx)(n.p,{children:"Manipulation strategies informed by:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["MoveIt 2 Documentation: ",(0,s.jsx)(n.a,{href:"https://moveit.picknik.ai/main",children:"moveit.picknik.ai/main"})]}),"\n",(0,s.jsxs)(n.li,{children:["Grasp Planning Best Practices: ",(0,s.jsx)(n.a,{href:"https://manipulation.csail.mit.edu/",children:"manipulation.csail.mit.edu"})]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"Manipulation transforms detected objects into physical task completion:"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"MoveIt 2"})," provides collision-free motion planning with configurable planners (OMPL, Pilz) and IK solvers"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Grasp strategies"})," balance efficiency (predefined grasps) with generality (heuristic grasps from geometry)"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Failure recovery"})," ensures robustness through retry logic, pose perturbation, and LLM replanning requests"]}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"State machine integration"})," sequences navigation \u2192 perception \u2192 manipulation for end-to-end autonomy"]}),"\n",(0,s.jsx)(n.p,{children:"Your capstone system now executes complete fetch-and-deliver tasks from voice commands\u2014demonstrating the full integration of AI and robotics."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Next Steps"}),": Explore ",(0,s.jsx)(n.a,{href:"/docs/modules/module-05-capstone/testing-methodology",children:"Testing Methodology"})," to validate manipulation in isolation, or proceed to ",(0,s.jsx)(n.a,{href:"/docs/modules/module-05-capstone/chapter-05-simulation-deployment",children:"Chapter 5: Simulation Deployment"})," to run the integrated system in Gazebo."]}),"\n",(0,s.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(n.p,{children:["\u2b50 ",(0,s.jsx)(n.strong,{children:"Exercise 1"}),": Measure grasp success rate for 20 trials with varying object positions. Identify dominant failure modes."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2b50\u2b50 ",(0,s.jsx)(n.strong,{children:"Exercise 2"}),": Implement a ",(0,s.jsx)(n.strong,{children:"force-feedback gripper"})," that detects successful grasps by monitoring gripper joint torques (grasp confirmed if torque > threshold)."]}),"\n",(0,s.jsxs)(n.p,{children:["\u2b50\u2b50\u2b50 ",(0,s.jsx)(n.strong,{children:"Exercise 3"}),": Create a ",(0,s.jsx)(n.strong,{children:"learned grasp planner"})," using PointNet++ to predict grasp poses from point cloud data (vs. heuristic bbox approach)."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Word Count"}),": 285 words (Target: 250-300) \u2705"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(p,{...e})}):p(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function o(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);